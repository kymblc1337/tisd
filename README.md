# Отчет по лабораторной работе №1

## Условия задачи
Составить программу деления двух чисел, где порядок имеет до 5 знаков: от
–99999 до +99999, а мантисса – до 30 знаков. Программа должна осуществлять ввод
чисел и выдавать выдавать, в зависимости от корректности введенных данных либо
результат деления, либо сообщение об ошибке.

## ТЗ
### Исходные данные и результаты
Смоделировать операцию деления действительного числа на действительное число в
форме +-m.nE+-K, где суммарная длина  мантиссы (m+n) – до 30 значащих цифр, а
величина порядка K – до 5 цифр. Результат выдать в форме +-0.m1, где m1 – до
30 значащих цифр, а K1 – до  5 цифр.

#### Входные данные
Делимое и делитель – действительные числа. Возможны следующие варианты ввода:

* „Е“ и „е“ - будет интерпретировано одинаково.
*  Отсутсвие знака будет интерпретировано как знак „+“
* +-m.n
* +-m.n E+-K;
* -+me+-K;

Результат работы: на экран выводится вещественное число, являющееся
результатом деления двух введенных, в форме +-0.m1 Е +-K1,
где число m1 определено до 30 значащих цифр, число K1 – до 5 цифр. При
невозможности произвести деление или некорректном формате ввода выдается сообщение об ошибке и работа программы прекращается.

### Описание задачи, реализуемой программой
Осуществляется деление двух вещественных десятичных чисел с
помощью последовательных операций вычитания.

### Способ обращения к программе
Запуск исполняемого файла, ввод исходных данных в окно консоли.

## Аварийные ситуации
* Неверный ввод числа – сообщение об ошибке ввода;
* Пустое поле ввода или отсутвие чисел преред E - будет интерпритировано как нуль
* Переполнение порядка – сообщение о переполнении;
* Деление на ноль – сообщение о запрещение деления на ноль.

# Описание использованных структур данныхфыв
Для представления чисел используется структура данных big_number. Реализация представлена ниже:
```
typedef struct  
{  
	int mantissa[MASSIZE];  // массив, каждым элементов которого является
				// цифра мантиссы 
	int mas_size = 0;	// размер мантиссы
	int power = 0;  	// степень числа в экспоненциальной форме
	int sign = 1;		// отвечает за знак (1 -> положительное, -1 -> отрицательное)
}big_number;
```

# Описание алгоритма
Два вещественных десятичных числа (числитель и знаменатель) считываются со
стандартного потока ввода (с клавиатуры). Производятся проверки на
правильность формата ввода. Производится проверка, является ли нулем знаменатель. Если знаменатель нуль - программы выдаст ошибку, тк пользователь хочет попытаться разделить что-то на нуль. В противном случае проверка, является ли нулем числитель. В случае, когда числитель нуль - программа выдаст, не исполняя основном алгоритм, выдаст результат 0E0. Далее необходимо "причесать" число - убрать из мантиссы незначащие нули, и получить, например, из числа *100E1* число *1E3*

Алгоритм деления происходит по классическому алгоритму "деления в столбик". Для начала мы приводим первое число в подходящий вид: делаем делимое больше делителя. Следующим шагом мы выбираем ту часть числа, которую будем делить первой. Далее, согласно известному алгоритму, вычитаем до тех пор из выбранной части делитель, пока это возможно. Количество раз, которое мы произвели вычитание записываем в ответ, "сносим" из делимого числа следующую цифру. Повторяем операцию. В случае невозможности вычитания записываем нуль.

Когда у делимого заканчиваются цифры для "снесения" мы так же продолжаем сносить нули, однако при этом в отдельную переменную записываем количество таких "снесенных" нулей. Говоря проще - эта переменная показывает, сколько знаков после точки будет в результате деления. Это будет использовано в вычислении степени числа в экспоненциальной форме. Весь алгоритм выполнять до тех пор, пока выбранная часть числа не разделиться нацело, либо пока длина мантиссы не станет 31 символ.

Округлить число, если это необходимо и вывести его в экспоненциальной форме.
# Тесты
| Делимое | Делитель | Результат |
|---------|----------|-----------|
| 2 | 3 | 0.666666666666666666666666666667E0 |
| 1 | 3 | 0.333333333333333333333333333333E0 |
| 0 | 2 | 0E0 |
| 4 | 2 | 0.2E1 |
| 1e99999 | 1e99999 | 0.1E1 |
| 999999999999999999999999999999 | 999999999999999999999999999999 | 0.1E1 |
| -999999999999999999999999999999 | -999999999999999999999999999999 | 0.1E1 |
| -999999999999999999999999999999 | 999999999999999999999999999999 | -0.1E1 |
| 2 | 0 | ERROR |
| 0 | 0 | ERROR |
| 'a' | 2 | ERROR |
| 1E999999 | 2 | ERROR |
| 1e99999 | 1e-1 | ERROR |
| 123456789123456789123456789123456789 | 1 | ERROR |

# Ответы на контрольные вопросы

## 1. Каков возможный диапазон чисел, представляемых в ПК?
Диапазон конкретного числа напрямую зависит от памяти, выделяемой для хранения данного числа. Так же на него влияют наличие знака у числа, а так же тип представления(вещественное или целое число). К примеру, если целая беззнаковая переменная типа int занимает 4 байта, то диапазон её значений: 0..216-1. Если же она может принимать также и положительные значения, то диапазон: -2^15..2^15-1
## 2.Какова возможная точность представления чисел? 
Вещественные числа хранятся в представлении с плавающей точкой в виде X = M * E^p, где М – мантисса, представленная дробью в интервале 0.1..1. Точность представленяи вещественного числа зависит от максимально возможной длины мантиссы, которая так же зависит от количества выделяемой памяти и наличия знака. Если длина мантиссы выходит за границы разрядной сетки, будет произведено ее округление.

## 3. Какие стандартные операции возможны над числами?
Стандартные операции над числами – сложение, вычитание, умножение, деление

## 4.Какой тип данных может выбрать программист, если обрабатываемые числа превышают возможный диапазон представления чисел в ПК?
Для работы с числами, превышающими возможный диапазон, может быть использован массив из цифр (пример - массив mantissa в моем реализации) – хороший способ представления целого беззнакового числа. В общем случае лучшей практикой будет использовать структуру данных, содержащую больше информации о числе(как пример - структура данных big_number, описанная выше)

## 5.Как можно осуществить операции над числами, выходящими за рамки машинного представления? 
Во-первых необходимо хранить их так, как описано в п4. Операции над ними выполняются поразрядно, если это сложение или вычитани. Если это более сложная операция, то операции приходится осуществлять нетревиально, например, над небольшими частями числа, как это выполнено в лабораторной работе №1.
